// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.

package api

/*
#include <stdlib.h>
*/
import "C"

import (
	"context"
	"fmt"
	"unsafe"

	"github.com/ivere27/synurang/pkg/synurang"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/proto"
)

// =============================================================================
// FFI Server Interface
// =============================================================================

type FfiServer interface {
	GoGreeterServiceServer
	BarServerStreamInternal(context.Context, *HelloRequest) (*HelloResponse, error)
	BarClientStreamInternal(context.Context, *HelloRequest) (*HelloResponse, error)
	BarBidiStreamInternal(context.Context, *HelloRequest) (*HelloResponse, error)
	UploadFileInternal(context.Context, *FileChunk) (*FileStatus, error)
	DownloadFileInternal(context.Context, *DownloadFileRequest) (*FileChunk, error)
	BidiFileInternal(context.Context, *FileChunk) (*FileChunk, error)
	DartGreeterServiceServer
	FooServerStreamInternal(context.Context, *HelloRequest) (*HelloResponse, error)
	FooClientStreamInternal(context.Context, *HelloRequest) (*HelloResponse, error)
	FooBidiStreamInternal(context.Context, *HelloRequest) (*HelloResponse, error)
	DartUploadFileInternal(context.Context, *FileChunk) (*FileStatus, error)
	DartDownloadFileInternal(context.Context, *DownloadFileRequest) (*FileChunk, error)
	DartBidiFileInternal(context.Context, *FileChunk) (*FileChunk, error)
}

// =============================================================================
// Invoke - returns []byte (for TCP/UDS)
// =============================================================================

func Invoke(s FfiServer, ctx context.Context, method string, data []byte) ([]byte, error) {
	switch method {
	case "/example.v1.GoGreeterService/Bar":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Bar(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.GoGreeterService/BarServerStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BarServerStreamInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.GoGreeterService/BarClientStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BarClientStreamInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.GoGreeterService/BarBidiStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BarBidiStreamInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.GoGreeterService/UploadFile":
		req := &FileChunk{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UploadFileInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.GoGreeterService/DownloadFile":
		req := &DownloadFileRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DownloadFileInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.GoGreeterService/BidiFile":
		req := &FileChunk{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BidiFileInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.GoGreeterService/Trigger":
		req := &TriggerRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Trigger(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.GoGreeterService/GetGoroutines":
		req := &GoroutinesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetGoroutines(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.DartGreeterService/Foo":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Foo(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.DartGreeterService/FooServerStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FooServerStreamInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.DartGreeterService/FooClientStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FooClientStreamInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.DartGreeterService/FooBidiStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FooBidiStreamInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.DartGreeterService/DartUploadFile":
		req := &FileChunk{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DartUploadFileInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.DartGreeterService/DartDownloadFile":
		req := &DownloadFileRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DartDownloadFileInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/example.v1.DartGreeterService/DartBidiFile":
		req := &FileChunk{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DartBidiFileInternal(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	default:
		return nil, fmt.Errorf("unknown method: %s", method)
	}
}

// =============================================================================
// InvokeFfi - returns C pointer (for zero-copy FFI)
// =============================================================================

// InvokeFfi is the zero-copy variant for FFI mode.
// It allocates C memory and serializes directly into it.
// Caller is responsible for freeing the returned pointer via C.free().
func InvokeFfi(s FfiServer, ctx context.Context, method string, data []byte) (unsafe.Pointer, int64, error) {
	switch method {
	case "/example.v1.GoGreeterService/Bar":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Bar(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.GoGreeterService/BarServerStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BarServerStreamInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.GoGreeterService/BarClientStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BarClientStreamInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.GoGreeterService/BarBidiStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BarBidiStreamInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.GoGreeterService/UploadFile":
		req := &FileChunk{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.UploadFileInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.GoGreeterService/DownloadFile":
		req := &DownloadFileRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DownloadFileInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.GoGreeterService/BidiFile":
		req := &FileChunk{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.BidiFileInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.GoGreeterService/Trigger":
		req := &TriggerRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Trigger(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.GoGreeterService/GetGoroutines":
		req := &GoroutinesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetGoroutines(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.DartGreeterService/Foo":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Foo(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.DartGreeterService/FooServerStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FooServerStreamInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.DartGreeterService/FooClientStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FooClientStreamInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.DartGreeterService/FooBidiStream":
		req := &HelloRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.FooBidiStreamInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.DartGreeterService/DartUploadFile":
		req := &FileChunk{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DartUploadFileInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.DartGreeterService/DartDownloadFile":
		req := &DownloadFileRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DartDownloadFileInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/example.v1.DartGreeterService/DartBidiFile":
		req := &FileChunk{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.DartBidiFileInternal(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		if cPtr == nil {
			return nil, 0, fmt.Errorf("failed to allocate memory for response")
		}
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	default:
		return nil, 0, fmt.Errorf("unknown method: %s", method)
	}
}

// =============================================================================
// InvokeStream - dispatches streaming RPC calls
// =============================================================================

func InvokeStream(s FfiServer, ctx context.Context, method string, stream grpc.ServerStream) error {
	switch method {
	case "/example.v1.GoGreeterService/BarServerStream":
		req := &HelloRequest{}
		if err := stream.RecvMsg(req); err != nil {
			return err
		}
		return s.BarServerStream(req, &grpcGoGreeterServiceBarServerStreamStream{stream})
	case "/example.v1.GoGreeterService/BarClientStream":
		return s.BarClientStream(&grpcGoGreeterServiceBarClientStreamStream{stream})
	case "/example.v1.GoGreeterService/BarBidiStream":
		return s.BarBidiStream(&grpcGoGreeterServiceBarBidiStreamStream{stream})
	case "/example.v1.GoGreeterService/UploadFile":
		return s.UploadFile(&grpcGoGreeterServiceUploadFileStream{stream})
	case "/example.v1.GoGreeterService/DownloadFile":
		req := &DownloadFileRequest{}
		if err := stream.RecvMsg(req); err != nil {
			return err
		}
		return s.DownloadFile(req, &grpcGoGreeterServiceDownloadFileStream{stream})
	case "/example.v1.GoGreeterService/BidiFile":
		return s.BidiFile(&grpcGoGreeterServiceBidiFileStream{stream})
	case "/example.v1.DartGreeterService/FooServerStream":
		req := &HelloRequest{}
		if err := stream.RecvMsg(req); err != nil {
			return err
		}
		return s.FooServerStream(req, &grpcDartGreeterServiceFooServerStreamStream{stream})
	case "/example.v1.DartGreeterService/FooClientStream":
		return s.FooClientStream(&grpcDartGreeterServiceFooClientStreamStream{stream})
	case "/example.v1.DartGreeterService/FooBidiStream":
		return s.FooBidiStream(&grpcDartGreeterServiceFooBidiStreamStream{stream})
	case "/example.v1.DartGreeterService/DartUploadFile":
		return s.DartUploadFile(&grpcDartGreeterServiceDartUploadFileStream{stream})
	case "/example.v1.DartGreeterService/DartDownloadFile":
		req := &DownloadFileRequest{}
		if err := stream.RecvMsg(req); err != nil {
			return err
		}
		return s.DartDownloadFile(req, &grpcDartGreeterServiceDartDownloadFileStream{stream})
	case "/example.v1.DartGreeterService/DartBidiFile":
		return s.DartBidiFile(&grpcDartGreeterServiceDartBidiFileStream{stream})
	default:
		return fmt.Errorf("unknown streaming method: %s", method)
	}
}

// =============================================================================
// gRPC Stream Wrappers
// =============================================================================

type grpcGoGreeterServiceBarServerStreamStream struct {
	grpc.ServerStream
}

func (s *grpcGoGreeterServiceBarServerStreamStream) Send(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

var _ GoGreeterService_BarServerStreamServer = (*grpcGoGreeterServiceBarServerStreamStream)(nil)

type grpcGoGreeterServiceBarClientStreamStream struct {
	grpc.ServerStream
}

func (s *grpcGoGreeterServiceBarClientStreamStream) Recv() (*HelloRequest, error) {
	m := &HelloRequest{}
	if err := s.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (s *grpcGoGreeterServiceBarClientStreamStream) SendAndClose(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

var _ GoGreeterService_BarClientStreamServer = (*grpcGoGreeterServiceBarClientStreamStream)(nil)

type grpcGoGreeterServiceBarBidiStreamStream struct {
	grpc.ServerStream
}

func (s *grpcGoGreeterServiceBarBidiStreamStream) Send(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

func (s *grpcGoGreeterServiceBarBidiStreamStream) Recv() (*HelloRequest, error) {
	m := &HelloRequest{}
	if err := s.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ GoGreeterService_BarBidiStreamServer = (*grpcGoGreeterServiceBarBidiStreamStream)(nil)

type grpcGoGreeterServiceUploadFileStream struct {
	grpc.ServerStream
}

func (s *grpcGoGreeterServiceUploadFileStream) Recv() (*FileChunk, error) {
	m := &FileChunk{}
	if err := s.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (s *grpcGoGreeterServiceUploadFileStream) SendAndClose(m *FileStatus) error {
	return s.ServerStream.SendMsg(m)
}

var _ GoGreeterService_UploadFileServer = (*grpcGoGreeterServiceUploadFileStream)(nil)

type grpcGoGreeterServiceDownloadFileStream struct {
	grpc.ServerStream
}

func (s *grpcGoGreeterServiceDownloadFileStream) Send(m *FileChunk) error {
	return s.ServerStream.SendMsg(m)
}

var _ GoGreeterService_DownloadFileServer = (*grpcGoGreeterServiceDownloadFileStream)(nil)

type grpcGoGreeterServiceBidiFileStream struct {
	grpc.ServerStream
}

func (s *grpcGoGreeterServiceBidiFileStream) Send(m *FileChunk) error {
	return s.ServerStream.SendMsg(m)
}

func (s *grpcGoGreeterServiceBidiFileStream) Recv() (*FileChunk, error) {
	m := &FileChunk{}
	if err := s.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ GoGreeterService_BidiFileServer = (*grpcGoGreeterServiceBidiFileStream)(nil)

type grpcDartGreeterServiceFooServerStreamStream struct {
	grpc.ServerStream
}

func (s *grpcDartGreeterServiceFooServerStreamStream) Send(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

var _ DartGreeterService_FooServerStreamServer = (*grpcDartGreeterServiceFooServerStreamStream)(nil)

type grpcDartGreeterServiceFooClientStreamStream struct {
	grpc.ServerStream
}

func (s *grpcDartGreeterServiceFooClientStreamStream) Recv() (*HelloRequest, error) {
	m := &HelloRequest{}
	if err := s.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (s *grpcDartGreeterServiceFooClientStreamStream) SendAndClose(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

var _ DartGreeterService_FooClientStreamServer = (*grpcDartGreeterServiceFooClientStreamStream)(nil)

type grpcDartGreeterServiceFooBidiStreamStream struct {
	grpc.ServerStream
}

func (s *grpcDartGreeterServiceFooBidiStreamStream) Send(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

func (s *grpcDartGreeterServiceFooBidiStreamStream) Recv() (*HelloRequest, error) {
	m := &HelloRequest{}
	if err := s.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ DartGreeterService_FooBidiStreamServer = (*grpcDartGreeterServiceFooBidiStreamStream)(nil)

type grpcDartGreeterServiceDartUploadFileStream struct {
	grpc.ServerStream
}

func (s *grpcDartGreeterServiceDartUploadFileStream) Recv() (*FileChunk, error) {
	m := &FileChunk{}
	if err := s.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (s *grpcDartGreeterServiceDartUploadFileStream) SendAndClose(m *FileStatus) error {
	return s.ServerStream.SendMsg(m)
}

var _ DartGreeterService_DartUploadFileServer = (*grpcDartGreeterServiceDartUploadFileStream)(nil)

type grpcDartGreeterServiceDartDownloadFileStream struct {
	grpc.ServerStream
}

func (s *grpcDartGreeterServiceDartDownloadFileStream) Send(m *FileChunk) error {
	return s.ServerStream.SendMsg(m)
}

var _ DartGreeterService_DartDownloadFileServer = (*grpcDartGreeterServiceDartDownloadFileStream)(nil)

type grpcDartGreeterServiceDartBidiFileStream struct {
	grpc.ServerStream
}

func (s *grpcDartGreeterServiceDartBidiFileStream) Send(m *FileChunk) error {
	return s.ServerStream.SendMsg(m)
}

func (s *grpcDartGreeterServiceDartBidiFileStream) Recv() (*FileChunk, error) {
	m := &FileChunk{}
	if err := s.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ DartGreeterService_DartBidiFileServer = (*grpcDartGreeterServiceDartBidiFileStream)(nil)

// =============================================================================
// FFI Invoker - wraps FfiServer to implement synurang.Invoker interface
// =============================================================================

// ffiInvoker wraps FfiServer to implement the synurang.Invoker interface.
// This allows using the synurang runtime's FfiClientConn with generated code.
// Uses zero-copy: proto.Message pointers are passed directly without serialization.
type ffiInvoker struct {
	server FfiServer
}

// Invoke implements synurang.UnaryInvoker (zero-copy).
func (i *ffiInvoker) Invoke(ctx context.Context, method string, req, reply proto.Message) error {
	switch method {
	case "/example.v1.GoGreeterService/Bar":
		resp, err := i.server.Bar(ctx, req.(*HelloRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.GoGreeterService/BarServerStream":
		resp, err := i.server.BarServerStreamInternal(ctx, req.(*HelloRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.GoGreeterService/BarClientStream":
		resp, err := i.server.BarClientStreamInternal(ctx, req.(*HelloRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.GoGreeterService/BarBidiStream":
		resp, err := i.server.BarBidiStreamInternal(ctx, req.(*HelloRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.GoGreeterService/UploadFile":
		resp, err := i.server.UploadFileInternal(ctx, req.(*FileChunk))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.GoGreeterService/DownloadFile":
		resp, err := i.server.DownloadFileInternal(ctx, req.(*DownloadFileRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.GoGreeterService/BidiFile":
		resp, err := i.server.BidiFileInternal(ctx, req.(*FileChunk))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.GoGreeterService/Trigger":
		resp, err := i.server.Trigger(ctx, req.(*TriggerRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.GoGreeterService/GetGoroutines":
		resp, err := i.server.GetGoroutines(ctx, req.(*GoroutinesRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.DartGreeterService/Foo":
		resp, err := i.server.Foo(ctx, req.(*HelloRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.DartGreeterService/FooServerStream":
		resp, err := i.server.FooServerStreamInternal(ctx, req.(*HelloRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.DartGreeterService/FooClientStream":
		resp, err := i.server.FooClientStreamInternal(ctx, req.(*HelloRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.DartGreeterService/FooBidiStream":
		resp, err := i.server.FooBidiStreamInternal(ctx, req.(*HelloRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.DartGreeterService/DartUploadFile":
		resp, err := i.server.DartUploadFileInternal(ctx, req.(*FileChunk))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.DartGreeterService/DartDownloadFile":
		resp, err := i.server.DartDownloadFileInternal(ctx, req.(*DownloadFileRequest))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	case "/example.v1.DartGreeterService/DartBidiFile":
		resp, err := i.server.DartBidiFileInternal(ctx, req.(*FileChunk))
		if err != nil {
			return err
		}
		// Use proto.Merge to avoid copying mutex in MessageState
		proto.Merge(reply.(proto.Message), resp)
		return nil
	default:
		return fmt.Errorf("unknown method: %s", method)
	}
}

// InvokeStream implements synurang.StreamInvoker (zero-copy).
func (i *ffiInvoker) InvokeStream(ctx context.Context, method string, stream synurang.ServerStream) error {
	switch method {
	case "/example.v1.GoGreeterService/BarServerStream":
		// Server streaming (zero-copy)
		reqMsg, err := stream.RecvMsgDirect()
		if err != nil {
			return err
		}
		req := reqMsg.(*HelloRequest)
		return i.server.BarServerStream(req, &ffiGoGreeterServiceBarServerStreamStream{stream})
	case "/example.v1.GoGreeterService/BarClientStream":
		// Client streaming (zero-copy)
		return i.server.BarClientStream(&ffiGoGreeterServiceBarClientStreamStream{stream})
	case "/example.v1.GoGreeterService/BarBidiStream":
		// Bidi streaming (zero-copy)
		return i.server.BarBidiStream(&ffiGoGreeterServiceBarBidiStreamStream{stream})
	case "/example.v1.GoGreeterService/UploadFile":
		// Client streaming (zero-copy)
		return i.server.UploadFile(&ffiGoGreeterServiceUploadFileStream{stream})
	case "/example.v1.GoGreeterService/DownloadFile":
		// Server streaming (zero-copy)
		reqMsg, err := stream.RecvMsgDirect()
		if err != nil {
			return err
		}
		req := reqMsg.(*DownloadFileRequest)
		return i.server.DownloadFile(req, &ffiGoGreeterServiceDownloadFileStream{stream})
	case "/example.v1.GoGreeterService/BidiFile":
		// Bidi streaming (zero-copy)
		return i.server.BidiFile(&ffiGoGreeterServiceBidiFileStream{stream})
	case "/example.v1.DartGreeterService/FooServerStream":
		// Server streaming (zero-copy)
		reqMsg, err := stream.RecvMsgDirect()
		if err != nil {
			return err
		}
		req := reqMsg.(*HelloRequest)
		return i.server.FooServerStream(req, &ffiDartGreeterServiceFooServerStreamStream{stream})
	case "/example.v1.DartGreeterService/FooClientStream":
		// Client streaming (zero-copy)
		return i.server.FooClientStream(&ffiDartGreeterServiceFooClientStreamStream{stream})
	case "/example.v1.DartGreeterService/FooBidiStream":
		// Bidi streaming (zero-copy)
		return i.server.FooBidiStream(&ffiDartGreeterServiceFooBidiStreamStream{stream})
	case "/example.v1.DartGreeterService/DartUploadFile":
		// Client streaming (zero-copy)
		return i.server.DartUploadFile(&ffiDartGreeterServiceDartUploadFileStream{stream})
	case "/example.v1.DartGreeterService/DartDownloadFile":
		// Server streaming (zero-copy)
		reqMsg, err := stream.RecvMsgDirect()
		if err != nil {
			return err
		}
		req := reqMsg.(*DownloadFileRequest)
		return i.server.DartDownloadFile(req, &ffiDartGreeterServiceDartDownloadFileStream{stream})
	case "/example.v1.DartGreeterService/DartBidiFile":
		// Bidi streaming (zero-copy)
		return i.server.DartBidiFile(&ffiDartGreeterServiceDartBidiFileStream{stream})
	default:
		return fmt.Errorf("unknown streaming method: %s", method)
	}
}

// =============================================================================
// Stream Wrappers (zero-copy)
// =============================================================================

// ffiGoGreeterServiceBarServerStreamStream wraps ServerStream for zero-copy GoGreeterService.BarServerStream
type ffiGoGreeterServiceBarServerStreamStream struct {
	synurang.ServerStream
}

func (s *ffiGoGreeterServiceBarServerStreamStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiGoGreeterServiceBarServerStreamStream) Send(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

var _ GoGreeterService_BarServerStreamServer = (*ffiGoGreeterServiceBarServerStreamStream)(nil)

// ffiGoGreeterServiceBarClientStreamStream wraps ServerStream for zero-copy GoGreeterService.BarClientStream
type ffiGoGreeterServiceBarClientStreamStream struct {
	synurang.ServerStream
}

func (s *ffiGoGreeterServiceBarClientStreamStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiGoGreeterServiceBarClientStreamStream) Recv() (*HelloRequest, error) {
	msg, err := s.ServerStream.RecvMsgDirect()
	if err != nil {
		return nil, err
	}
	return msg.(*HelloRequest), nil
}

func (s *ffiGoGreeterServiceBarClientStreamStream) SendAndClose(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

var _ GoGreeterService_BarClientStreamServer = (*ffiGoGreeterServiceBarClientStreamStream)(nil)

// ffiGoGreeterServiceBarBidiStreamStream wraps ServerStream for zero-copy GoGreeterService.BarBidiStream
type ffiGoGreeterServiceBarBidiStreamStream struct {
	synurang.ServerStream
}

func (s *ffiGoGreeterServiceBarBidiStreamStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiGoGreeterServiceBarBidiStreamStream) Send(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

func (s *ffiGoGreeterServiceBarBidiStreamStream) Recv() (*HelloRequest, error) {
	msg, err := s.ServerStream.RecvMsgDirect()
	if err != nil {
		return nil, err
	}
	return msg.(*HelloRequest), nil
}

var _ GoGreeterService_BarBidiStreamServer = (*ffiGoGreeterServiceBarBidiStreamStream)(nil)

// ffiGoGreeterServiceUploadFileStream wraps ServerStream for zero-copy GoGreeterService.UploadFile
type ffiGoGreeterServiceUploadFileStream struct {
	synurang.ServerStream
}

func (s *ffiGoGreeterServiceUploadFileStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiGoGreeterServiceUploadFileStream) Recv() (*FileChunk, error) {
	msg, err := s.ServerStream.RecvMsgDirect()
	if err != nil {
		return nil, err
	}
	return msg.(*FileChunk), nil
}

func (s *ffiGoGreeterServiceUploadFileStream) SendAndClose(m *FileStatus) error {
	return s.ServerStream.SendMsg(m)
}

var _ GoGreeterService_UploadFileServer = (*ffiGoGreeterServiceUploadFileStream)(nil)

// ffiGoGreeterServiceDownloadFileStream wraps ServerStream for zero-copy GoGreeterService.DownloadFile
type ffiGoGreeterServiceDownloadFileStream struct {
	synurang.ServerStream
}

func (s *ffiGoGreeterServiceDownloadFileStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiGoGreeterServiceDownloadFileStream) Send(m *FileChunk) error {
	return s.ServerStream.SendMsg(m)
}

var _ GoGreeterService_DownloadFileServer = (*ffiGoGreeterServiceDownloadFileStream)(nil)

// ffiGoGreeterServiceBidiFileStream wraps ServerStream for zero-copy GoGreeterService.BidiFile
type ffiGoGreeterServiceBidiFileStream struct {
	synurang.ServerStream
}

func (s *ffiGoGreeterServiceBidiFileStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiGoGreeterServiceBidiFileStream) Send(m *FileChunk) error {
	return s.ServerStream.SendMsg(m)
}

func (s *ffiGoGreeterServiceBidiFileStream) Recv() (*FileChunk, error) {
	msg, err := s.ServerStream.RecvMsgDirect()
	if err != nil {
		return nil, err
	}
	return msg.(*FileChunk), nil
}

var _ GoGreeterService_BidiFileServer = (*ffiGoGreeterServiceBidiFileStream)(nil)

// ffiDartGreeterServiceFooServerStreamStream wraps ServerStream for zero-copy DartGreeterService.FooServerStream
type ffiDartGreeterServiceFooServerStreamStream struct {
	synurang.ServerStream
}

func (s *ffiDartGreeterServiceFooServerStreamStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiDartGreeterServiceFooServerStreamStream) Send(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

var _ DartGreeterService_FooServerStreamServer = (*ffiDartGreeterServiceFooServerStreamStream)(nil)

// ffiDartGreeterServiceFooClientStreamStream wraps ServerStream for zero-copy DartGreeterService.FooClientStream
type ffiDartGreeterServiceFooClientStreamStream struct {
	synurang.ServerStream
}

func (s *ffiDartGreeterServiceFooClientStreamStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiDartGreeterServiceFooClientStreamStream) Recv() (*HelloRequest, error) {
	msg, err := s.ServerStream.RecvMsgDirect()
	if err != nil {
		return nil, err
	}
	return msg.(*HelloRequest), nil
}

func (s *ffiDartGreeterServiceFooClientStreamStream) SendAndClose(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

var _ DartGreeterService_FooClientStreamServer = (*ffiDartGreeterServiceFooClientStreamStream)(nil)

// ffiDartGreeterServiceFooBidiStreamStream wraps ServerStream for zero-copy DartGreeterService.FooBidiStream
type ffiDartGreeterServiceFooBidiStreamStream struct {
	synurang.ServerStream
}

func (s *ffiDartGreeterServiceFooBidiStreamStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiDartGreeterServiceFooBidiStreamStream) Send(m *HelloResponse) error {
	return s.ServerStream.SendMsg(m)
}

func (s *ffiDartGreeterServiceFooBidiStreamStream) Recv() (*HelloRequest, error) {
	msg, err := s.ServerStream.RecvMsgDirect()
	if err != nil {
		return nil, err
	}
	return msg.(*HelloRequest), nil
}

var _ DartGreeterService_FooBidiStreamServer = (*ffiDartGreeterServiceFooBidiStreamStream)(nil)

// ffiDartGreeterServiceDartUploadFileStream wraps ServerStream for zero-copy DartGreeterService.DartUploadFile
type ffiDartGreeterServiceDartUploadFileStream struct {
	synurang.ServerStream
}

func (s *ffiDartGreeterServiceDartUploadFileStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiDartGreeterServiceDartUploadFileStream) Recv() (*FileChunk, error) {
	msg, err := s.ServerStream.RecvMsgDirect()
	if err != nil {
		return nil, err
	}
	return msg.(*FileChunk), nil
}

func (s *ffiDartGreeterServiceDartUploadFileStream) SendAndClose(m *FileStatus) error {
	return s.ServerStream.SendMsg(m)
}

var _ DartGreeterService_DartUploadFileServer = (*ffiDartGreeterServiceDartUploadFileStream)(nil)

// ffiDartGreeterServiceDartDownloadFileStream wraps ServerStream for zero-copy DartGreeterService.DartDownloadFile
type ffiDartGreeterServiceDartDownloadFileStream struct {
	synurang.ServerStream
}

func (s *ffiDartGreeterServiceDartDownloadFileStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiDartGreeterServiceDartDownloadFileStream) Send(m *FileChunk) error {
	return s.ServerStream.SendMsg(m)
}

var _ DartGreeterService_DartDownloadFileServer = (*ffiDartGreeterServiceDartDownloadFileStream)(nil)

// ffiDartGreeterServiceDartBidiFileStream wraps ServerStream for zero-copy DartGreeterService.DartBidiFile
type ffiDartGreeterServiceDartBidiFileStream struct {
	synurang.ServerStream
}

func (s *ffiDartGreeterServiceDartBidiFileStream) Context() context.Context {
	return s.ServerStream.Context()
}

func (s *ffiDartGreeterServiceDartBidiFileStream) Send(m *FileChunk) error {
	return s.ServerStream.SendMsg(m)
}

func (s *ffiDartGreeterServiceDartBidiFileStream) Recv() (*FileChunk, error) {
	msg, err := s.ServerStream.RecvMsgDirect()
	if err != nil {
		return nil, err
	}
	return msg.(*FileChunk), nil
}

var _ DartGreeterService_DartBidiFileServer = (*ffiDartGreeterServiceDartBidiFileStream)(nil)

var _ synurang.Invoker = (*ffiInvoker)(nil)

// =============================================================================
// FFI Client - convenience wrapper for synurang.FfiClientConn
// =============================================================================

func NewFfiClientConn(server FfiServer) grpc.ClientConnInterface {
	return synurang.NewFfiClientConn(&ffiInvoker{server: server})
}
