// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.

package api

import (
	empty "github.com/golang/protobuf/ptypes/empty"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
)

/*
#include <stdlib.h>
*/
import "C"

import (
	"context"
	"fmt"
	"unsafe"

	"github.com/ivere27/synurang/pkg/synurang"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/proto"
)

type FfiServer interface {
	HealthServiceServer
	CacheServiceServer
}

func Invoke(s FfiServer, ctx context.Context, method string, data []byte) ([]byte, error) {
	switch method {
	case "/core.v1.HealthService/Ping":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Ping(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/Get":
		req := &GetCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Get(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/Put":
		req := &PutCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Put(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/Delete":
		req := &DeleteCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Delete(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/Clear":
		req := &ClearCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Clear(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/Contains":
		req := &GetCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Contains(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/Keys":
		req := &GetCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Keys(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/SetMaxEntries":
		req := &SetMaxEntriesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SetMaxEntries(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/SetMaxBytes":
		req := &SetMaxBytesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SetMaxBytes(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/GetStats":
		req := &GetStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetStats(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	case "/core.v1.CacheService/Compact":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Compact(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
	default:
		return nil, fmt.Errorf("unknown method: %s", method)
	}
}

// InvokeFfi is the zero-copy variant for FFI mode.
// It allocates C memory and serializes directly into it.
// Caller is responsible for freeing the returned pointer via C.free().
func InvokeFfi(s FfiServer, ctx context.Context, method string, data []byte) (unsafe.Pointer, int64, error) {
	switch method {
	case "/core.v1.HealthService/Ping":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Ping(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/Get":
		req := &GetCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Get(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/Put":
		req := &PutCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Put(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/Delete":
		req := &DeleteCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Delete(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/Clear":
		req := &ClearCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Clear(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/Contains":
		req := &GetCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Contains(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/Keys":
		req := &GetCacheRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Keys(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/SetMaxEntries":
		req := &SetMaxEntriesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SetMaxEntries(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/SetMaxBytes":
		req := &SetMaxBytesRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.SetMaxBytes(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/GetStats":
		req := &GetStatsRequest{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.GetStats(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	case "/core.v1.CacheService/Compact":
		req := &empty.Empty{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := s.Compact(ctx, req)
		if err != nil {
			return nil, 0, err
		}
		// Zero-copy: allocate C memory and serialize directly
		size := proto.Size(resp)
		if size == 0 {
			return nil, 0, nil
		}
		cPtr := C.malloc(C.size_t(size))
		buf := unsafe.Slice((*byte)(cPtr), size)
		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {
			C.free(cPtr)
			return nil, 0, err
		}
		return cPtr, int64(size), nil
	default:
		return nil, 0, fmt.Errorf("unknown method: %s", method)
	}
}

// InvokeStream dispatches streaming RPC calls to the appropriate server method.
func InvokeStream(s FfiServer, ctx context.Context, method string, stream grpc.ServerStream) error {
	switch method {
	default:
		return fmt.Errorf("unknown streaming method: %s", method)
	}
}

// =============================================================================
// FFI Invoker - wraps FfiServer to implement synurang.Invoker interface
// =============================================================================

// ffiInvoker wraps FfiServer to implement the synurang.Invoker interface.
// This allows using the synurang runtime's FfiClientConn with generated code.
// Uses zero-copy: proto.Message pointers are passed directly without serialization.
type ffiInvoker struct {
	server FfiServer
}

// Invoke implements synurang.UnaryInvoker (zero-copy).
func (i *ffiInvoker) Invoke(ctx context.Context, method string, req, reply proto.Message) error {
	switch method {
	case "/core.v1.HealthService/Ping":
		resp, err := i.server.Ping(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*PingResponse)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/Get":
		resp, err := i.server.Get(ctx, req.(*GetCacheRequest))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*GetCacheResponse)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/Put":
		resp, err := i.server.Put(ctx, req.(*PutCacheRequest))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*empty.Empty)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/Delete":
		resp, err := i.server.Delete(ctx, req.(*DeleteCacheRequest))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*empty.Empty)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/Clear":
		resp, err := i.server.Clear(ctx, req.(*ClearCacheRequest))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*empty.Empty)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/Contains":
		resp, err := i.server.Contains(ctx, req.(*GetCacheRequest))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*wrappers.BoolValue)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/Keys":
		resp, err := i.server.Keys(ctx, req.(*GetCacheRequest))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*GetCacheKeysResponse)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/SetMaxEntries":
		resp, err := i.server.SetMaxEntries(ctx, req.(*SetMaxEntriesRequest))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*empty.Empty)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/SetMaxBytes":
		resp, err := i.server.SetMaxBytes(ctx, req.(*SetMaxBytesRequest))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*empty.Empty)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/GetStats":
		resp, err := i.server.GetStats(ctx, req.(*GetStatsRequest))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*GetStatsResponse)
		*dst = *resp
		return nil
	case "/core.v1.CacheService/Compact":
		resp, err := i.server.Compact(ctx, req.(*empty.Empty))
		if err != nil {
			return err
		}
		// Zero-copy: direct struct copy
		dst := reply.(*empty.Empty)
		*dst = *resp
		return nil
	default:
		return fmt.Errorf("unknown method: %s", method)
	}
}

// InvokeStream implements synurang.StreamInvoker (zero-copy).
func (i *ffiInvoker) InvokeStream(ctx context.Context, method string, stream synurang.ServerStream) error {
	switch method {
	default:
		return fmt.Errorf("unknown streaming method: %s", method)
	}
}

var _ synurang.Invoker = (*ffiInvoker)(nil)

// =============================================================================
// FFI Client - convenience wrapper for synurang.FfiClientConn
// =============================================================================

// NewFfiClientConn creates a new FFI client connection that implements
// grpc.ClientConnInterface. This allows using standard generated gRPC clients
// with embedded FFI calls instead of network transport.
// Supports unary and all streaming patterns (server, client, bidi).
// Uses zero-copy mode for Go-to-Go FFI (no serialization overhead).
func NewFfiClientConn(server FfiServer) grpc.ClientConnInterface {
	return synurang.NewFfiClientConn(&ffiInvoker{server: server})
}
