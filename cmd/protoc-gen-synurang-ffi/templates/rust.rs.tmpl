// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.

use prost::Message;
use std::sync::Arc;

// =============================================================================
// FFI Server Trait
// =============================================================================

pub trait FfiServer: Send + Sync {
{{- range $svc := .Services}}
{{- range $m := .Methods}}
    fn {{snakeCase $m.Name}}(&self, request: {{$m.InputType}}) -> Result<{{$m.OutputType}}, String>;
{{- end}}
{{- end}}
}

// =============================================================================
// FFI Dispatcher
// =============================================================================

pub fn invoke<S: FfiServer>(server: &S, method: &str, data: &[u8]) -> Result<Vec<u8>, String> {
    match method {
{{- range $svc := .Services}}
{{- range $m := .Methods}}
        "{{$m.FullMethodName}}" => {
            let request = {{$m.InputType}}::decode(data)
                .map_err(|e| format!("failed to decode request: {}", e))?;
            let response = server.{{snakeCase $m.Name}}(request)?;
            let mut buf = Vec::new();
            response.encode(&mut buf)
                .map_err(|e| format!("failed to encode response: {}", e))?;
            Ok(buf)
        }
{{- end}}
{{- end}}
        _ => Err(format!("unknown method: {}", method)),
    }
}

// =============================================================================
// FFI Client Connection - routes calls through FFI instead of network
// =============================================================================

pub struct FfiChannel<S: FfiServer> {
    server: Arc<S>,
}

impl<S: FfiServer> FfiChannel<S> {
    pub fn new(server: Arc<S>) -> Self {
        FfiChannel { server }
    }

    pub fn invoke<Req: Message, Resp: Message + Default>(&self, method: &str, request: &Req) -> Result<Resp, String> {
        let mut data = Vec::new();
        request.encode(&mut data)
            .map_err(|e| format!("failed to encode request: {}", e))?;
        let result = invoke(&*self.server, method, &data)?;
        Resp::decode(result.as_slice())
            .map_err(|e| format!("failed to decode response: {}", e))
    }
}
{{range $svc := .Services}}

// =============================================================================
// {{$svc.GoName}} FFI Client
// =============================================================================

pub struct {{$svc.GoName}}FfiClient<S: FfiServer> {
    conn: FfiChannel<S>,
}

impl<S: FfiServer> {{$svc.GoName}}FfiClient<S> {
    pub fn new(server: Arc<S>) -> Self {
        {{$svc.GoName}}FfiClient {
            conn: FfiChannel::new(server),
        }
    }
{{range $m := .Methods}}
    pub fn {{snakeCase $m.Name}}(&self, request: &{{$m.InputType}}) -> Result<{{$m.OutputType}}, String> {
        self.conn.invoke("{{$m.FullMethodName}}", request)
    }
{{end}}
}
{{end}}

// Module: {{.RustModPath}}
