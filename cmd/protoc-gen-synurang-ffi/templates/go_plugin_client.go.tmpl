// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.

package {{.GoPackageName}}

/*
#include <stdlib.h>
*/
import "C"

import (
	"context"
	"fmt"
	"unsafe"

	"google.golang.org/protobuf/proto"
{{- range .GoImports}}
	{{.Alias}} "{{.Path}}"
{{- end}}
)

// =============================================================================
// Plugin Client Mode - Host-side Loader and Typed Clients
// =============================================================================

// This file provides typed clients for loading and calling plugin shared libraries.
// It uses github.com/ebitengine/purego for cross-platform dynamic loading.
// Alternatively, you can use CGO with dlopen/dlsym directly.

// PluginError represents an error returned from a plugin.
type PluginError struct {
	Message string
}

func (e *PluginError) Error() string {
	return e.Message
}
{{range $svc := .Services}}

// =============================================================================
// {{$svc.GoName}} Plugin Client
// =============================================================================

// {{$svc.GoName}}PluginClient wraps a loaded plugin shared library.
type {{$svc.GoName}}PluginClient struct {
	invoke func(method *byte, data *byte, dataLen int32, respLen *int32) *byte
	free   func(ptr *byte)
}

// New{{$svc.GoName}}PluginClient creates a client from function pointers.
// Use purego.RegisterLibFunc to obtain these from a loaded .so/.dll.
//
// Example with purego:
//   lib, _ := purego.Dlopen("./plugin.so", purego.RTLD_LAZY)
//   var invoke func(*byte, *byte, int32, *int32) *byte
//   var free func(*byte)
//   purego.RegisterLibFunc(&invoke, lib, "Synurang_Invoke_{{$svc.GoName}}")
//   purego.RegisterLibFunc(&free, lib, "Synurang_Free")
//   client := New{{$svc.GoName}}PluginClient(invoke, free)
func New{{$svc.GoName}}PluginClient(invoke func(*byte, *byte, int32, *int32) *byte, free func(*byte)) *{{$svc.GoName}}PluginClient {
	return &{{$svc.GoName}}PluginClient{invoke: invoke, free: free}
}

func (c *{{$svc.GoName}}PluginClient) call(method string, reqBytes []byte) ([]byte, error) {
	methodBytes := append([]byte(method), 0) // null-terminated
	var respLen int32

	var dataPtr *byte
	if len(reqBytes) > 0 {
		dataPtr = &reqBytes[0]
	}

	resultPtr := c.invoke(&methodBytes[0], dataPtr, int32(len(reqBytes)), &respLen)
	if resultPtr == nil {
		return nil, fmt.Errorf("plugin returned nil")
	}
	defer c.free(resultPtr)

	// Copy result before freeing
	result := make([]byte, respLen)
	for i := int32(0); i < respLen; i++ {
		result[i] = *(*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(resultPtr)) + uintptr(i)))
	}

	// Check status byte
	if len(result) == 0 {
		return nil, fmt.Errorf("empty response from plugin")
	}
	if result[0] == 1 {
		return nil, &PluginError{Message: string(result[1:])}
	}
	return result[1:], nil
}
{{range $m := .Methods}}
{{if $m.IsUnary}}

// {{$m.GoName}} calls the {{$m.GoName}} method on the plugin.
func (c *{{$svc.GoName}}PluginClient) {{$m.GoName}}(ctx context.Context, req *{{$m.InputGoIdent}}) (*{{$m.OutputGoIdent}}, error) {
	_ = ctx // context not propagated to plugin (could add deadline)
	reqBytes, err := proto.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	respBytes, err := c.call("{{$m.FullMethodName}}", reqBytes)
	if err != nil {
		return nil, err
	}

	resp := &{{$m.OutputGoIdent}}{}
	if err := proto.Unmarshal(respBytes, resp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}
	return resp, nil
}
{{else}}
// {{$m.GoName}} - streaming not yet supported in plugin client mode
{{end}}
{{- end}}
{{end}}
