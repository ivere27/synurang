// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.

#ifndef {{.CppGuardName}}
#define {{.CppGuardName}}

#include <string>
#include <functional>
#include <memory>

#include "{{.PbHeaderFile}}"
{{if .CppNamespace}}
namespace {{.CppNamespace}} {
{{end}}
// =============================================================================
// FFI Server Interface
// =============================================================================

class FfiServer {
public:
  virtual ~FfiServer() = default;
{{range $svc := .Services}}
  // {{$svc.GoName}} methods
{{- range $m := .Methods}}
  virtual {{$m.OutputType}} {{$m.GoName}}(const {{$m.InputType}}& request) = 0;
{{- end}}
{{end}}
};

// =============================================================================
// FFI Dispatcher
// =============================================================================

inline std::string Invoke(FfiServer* server, const std::string& method, const std::string& data) {
{{- range $svc := .Services}}
{{- range $m := .Methods}}
  if (method == "{{$m.FullMethodName}}") {
    {{$m.InputType}} req;
    if (!req.ParseFromString(data)) {
      return "";  // Parse error
    }
    {{$m.OutputType}} resp = server->{{$m.GoName}}(req);
    return resp.SerializeAsString();
  }
{{- end}}
{{- end}}
  return "";  // Unknown method
}

// =============================================================================
// FFI Client Connection - routes calls through FFI instead of network
// =============================================================================

class FfiChannel {
public:
  explicit FfiChannel(FfiServer* server) : server_(server) {}

  template<typename Request, typename Response>
  bool Invoke(const std::string& method, const Request& request, Response* response) {
    std::string data = request.SerializeAsString();
{{- if .CppNamespace}}
    std::string result = ::{{.CppNamespace}}::Invoke(server_, method, data);
{{- else}}
    std::string result = Invoke(server_, method, data);
{{- end}}
    if (result.empty()) {
      return false;
    }
    return response->ParseFromString(result);
  }

private:
  FfiServer* server_;
};
{{range $svc := .Services}}

// =============================================================================
// {{$svc.GoName}} FFI Client
// =============================================================================

class {{$svc.GoName}}FfiClient {
public:
  explicit {{$svc.GoName}}FfiClient(FfiChannel* conn) : conn_(conn) {}
  explicit {{$svc.GoName}}FfiClient(FfiServer* server) : owned_conn_(std::make_unique<FfiChannel>(server)), conn_(owned_conn_.get()) {}
{{range $m := .Methods}}
  bool {{$m.GoName}}(const {{$m.InputType}}& request, {{$m.OutputType}}* response) {
    return conn_->Invoke("{{$m.FullMethodName}}", request, response);
  }
{{end}}
private:
  std::unique_ptr<FfiChannel> owned_conn_;
  FfiChannel* conn_;
};
{{end}}
{{if .CppNamespace}}
} // namespace {{.CppNamespace}}
{{end}}
#endif // {{.CppGuardName}}
