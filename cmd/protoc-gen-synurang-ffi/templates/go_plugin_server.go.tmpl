// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.

package {{.GoPackageName}}

/*
#include <stdlib.h>
*/
import "C"

import (
	"context"
	"fmt"
	"unsafe"
{{if .HasStreaming}}
	"io"

	"google.golang.org/grpc/metadata"
{{end}}
	"github.com/ivere27/synurang/pkg/plugin"
	"google.golang.org/protobuf/proto"
{{- range .GoImports}}
	{{.Alias}} "{{.Path}}"
{{- end}}
)

// trySendErr sends error to channel non-blocking
func trySendErr(ch chan<- error, err error) {
	select {
	case ch <- err:
	default:
	}
}

// =============================================================================
// Plugin Interfaces and Registration
// =============================================================================
{{range $svc := .Services}}

// {{$svc.GoName}}Plugin is the interface that plugin implementations must satisfy.
// Only methods for this specific service are required.
type {{$svc.GoName}}Plugin interface {
{{- range $m := .Methods}}
{{- if $m.IsServerStreaming}}
	{{$m.GoName}}(*{{$m.InputGoIdent}}, {{$svc.GoName}}_{{$m.GoName}}Server) error
{{- else if $m.IsClientStreaming}}
	{{$m.GoName}}({{$svc.GoName}}_{{$m.GoName}}Server) (*{{$m.OutputGoIdent}}, error)
{{- else if $m.IsBidiStreaming}}
	{{$m.GoName}}({{$svc.GoName}}_{{$m.GoName}}Server) error
{{- else}}
	{{$m.GoName}}(context.Context, *{{$m.InputGoIdent}}) (*{{$m.OutputGoIdent}}, error)
{{- end}}
{{- end}}
}

var plugin{{$svc.GoName}} {{$svc.GoName}}Plugin

// Register{{$svc.GoName}}Plugin sets the plugin implementation for {{$svc.GoName}}.
// This must be called in the plugin's init() function.
func Register{{$svc.GoName}}Plugin(s {{$svc.GoName}}Plugin) {
	plugin{{$svc.GoName}} = s
}
{{end}}

// =============================================================================
// Internal Invoke Functions (unary methods only)
// =============================================================================
{{range $svc := .Services}}

func invoke{{$svc.GoName}}(ctx context.Context, method string, data []byte) ([]byte, error) {
	if plugin{{$svc.GoName}} == nil {
		return nil, fmt.Errorf("plugin not registered for {{$svc.GoName}}")
	}
	switch method {
{{- range $m := .Methods}}
{{- if $m.IsUnary}}
	case "{{$m.FullMethodName}}":
		req := &{{$m.InputGoIdent}}{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, fmt.Errorf("failed to unmarshal request: %w", err)
		}
		resp, err := plugin{{$svc.GoName}}.{{$m.GoName}}(ctx, req)
		if err != nil {
			return nil, err
		}
		return proto.Marshal(resp)
{{- end}}
{{- end}}
	default:
		return nil, fmt.Errorf("unknown method: %s", method)
	}
}
{{end}}

// =============================================================================
// C-Exported Functions
// =============================================================================

// Response format: [status:1][payload...]
// status=0: success, payload=protobuf response
// status=1: error, payload=error string
{{range $svc := .Services}}

//export Synurang_Invoke_{{$svc.GoName}}
func Synurang_Invoke_{{$svc.GoName}}(method *C.char, data *C.char, dataLen C.int, respLen *C.int) *C.char {
	ctx := context.Background()
	m := C.GoString(method)

	// Handle nil data safely
	var d []byte
	if data != nil && dataLen > 0 {
		d = C.GoBytes(unsafe.Pointer(data), dataLen)
	}

	res, err := invoke{{$svc.GoName}}(ctx, m, d)
	if err != nil {
		// Return error with status byte = 1
		errBytes := []byte(err.Error())
		result := make([]byte, 1+len(errBytes))
		result[0] = 1 // error status
		copy(result[1:], errBytes)
		*respLen = C.int(len(result))
		return (*C.char)(C.CBytes(result))
	}

	// Return success with status byte = 0
	result := make([]byte, 1+len(res))
	result[0] = 0 // success status
	copy(result[1:], res)
	*respLen = C.int(len(result))
	return (*C.char)(C.CBytes(result))
}
{{end}}

{{if .HasStreaming}}
// =============================================================================
// Streaming Support
// =============================================================================
{{range $svc := .Services}}

//export Synurang_Stream_{{$svc.GoName}}_Open
func Synurang_Stream_{{$svc.GoName}}_Open(method *C.char) C.ulonglong {
	if plugin{{$svc.GoName}} == nil {
		return 0
	}

	m := C.GoString(method)
	handle, ps := plugin.NewStream(m)

	// Start stream handler goroutine
	go func() {
		defer ps.CloseRecvCh()
		defer ps.Cancel()

		// Recover from panics in plugin methods
		defer func() {
			if r := recover(); r != nil {
				trySendErr(ps.ErrCh, fmt.Errorf("panic in plugin: %v", r))
			}
		}()

		switch m {
{{- range $m := .Methods}}
{{- if not $m.IsUnary}}
		case "{{$m.FullMethodName}}":
{{- if $m.IsServerStreaming}}
			// Server streaming - receive initial request, then send responses
			select {
			case data := <-ps.SendCh:
				req := &{{$m.InputGoIdent}}{}
				if err := proto.Unmarshal(data, req); err != nil {
					trySendErr(ps.ErrCh, err)
					return
				}
				if err := plugin{{$svc.GoName}}.{{$m.GoName}}(req, &{{pluginStreamType $svc $m}}{ps}); err != nil && err != io.EOF {
					trySendErr(ps.ErrCh, err)
				}
			case <-ps.Ctx.Done():
				return
			}
{{- else if $m.IsClientStreaming}}
			// Client streaming
			resp, err := plugin{{$svc.GoName}}.{{$m.GoName}}(&{{pluginStreamType $svc $m}}{ps})
			if err != nil {
				trySendErr(ps.ErrCh, err)
				return
			}
			if data, err := proto.Marshal(resp); err != nil {
				trySendErr(ps.ErrCh, err)
			} else {
				select {
				case ps.RecvCh <- data:
				case <-ps.Ctx.Done():
				}
			}
{{- else}}
			// Bidi streaming
			if err := plugin{{$svc.GoName}}.{{$m.GoName}}(&{{pluginStreamType $svc $m}}{ps}); err != nil && err != io.EOF {
				trySendErr(ps.ErrCh, err)
			}
{{- end}}
{{- end}}
{{- end}}
		}
	}()

	return C.ulonglong(handle)
}
{{end}}

// =============================================================================
// Plugin Stream Wrappers
// =============================================================================
{{range $svc := .Services}}
{{- range $m := .Methods}}
{{- if not $m.IsUnary}}

type {{pluginStreamType $svc $m}} struct {
	ps *plugin.PluginStream
}

func (s *{{pluginStreamType $svc $m}}) Context() context.Context {
	return s.ps.Ctx
}
{{if or $m.IsServerStreaming $m.IsBidiStreaming}}
func (s *{{pluginStreamType $svc $m}}) Send(m *{{$m.OutputGoIdent}}) error {
	data, err := proto.Marshal(m)
	if err != nil {
		return err
	}
	select {
	case s.ps.RecvCh <- data:
		return nil
	case <-s.ps.Ctx.Done():
		return s.ps.Ctx.Err()
	}
}
{{end}}
{{if or $m.IsClientStreaming $m.IsBidiStreaming}}
func (s *{{pluginStreamType $svc $m}}) Recv() (*{{$m.InputGoIdent}}, error) {
	select {
	case data, ok := <-s.ps.SendCh:
		if !ok {
			return nil, io.EOF
		}
		req := &{{$m.InputGoIdent}}{}
		if err := proto.Unmarshal(data, req); err != nil {
			return nil, err
		}
		return req, nil
	case <-s.ps.Ctx.Done():
		return nil, s.ps.Ctx.Err()
	}
}
{{end}}
{{if $m.IsClientStreaming}}
func (s *{{pluginStreamType $svc $m}}) SendAndClose(m *{{$m.OutputGoIdent}}) error {
	data, err := proto.Marshal(m)
	if err != nil {
		return err
	}
	select {
	case s.ps.RecvCh <- data:
		return nil
	case <-s.ps.Ctx.Done():
		return s.ps.Ctx.Err()
	}
}
{{end}}
func (s *{{pluginStreamType $svc $m}}) SetHeader(metadata.MD) error { return nil }
func (s *{{pluginStreamType $svc $m}}) SendHeader(metadata.MD) error { return nil }
func (s *{{pluginStreamType $svc $m}}) SetTrailer(metadata.MD) {}
func (s *{{pluginStreamType $svc $m}}) SendMsg(m any) error { return nil }
func (s *{{pluginStreamType $svc $m}}) RecvMsg(m any) error { return nil }
{{- end}}
{{- end}}
{{- end}}
{{end}}
