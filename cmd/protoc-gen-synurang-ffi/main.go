package main

import (
	"flag"
	"fmt"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	var flags flag.FlagSet
	lang := flags.String("lang", "", "language to generate (go, dart, cpp, or rust)")
	dartPackage := flags.String("dart_package", "", "Dart package name for imports (e.g. my_app). If set, generates package imports.")
	services := flags.String("services", "", "comma-separated list of services to generate for (empty for all)")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		serviceList := make(map[string]bool)
		if *services != "" {
			for _, s := range strings.Split(*services, ",") {
				serviceList[strings.TrimSpace(s)] = true
			}
		}

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if *lang == "go" || *lang == "" {
				generateGoFile(gen, f, serviceList)
			}
			if *lang == "dart" || *lang == "" {
				generateDartFile(gen, f, serviceList, *dartPackage)
			}
			if *lang == "cpp" {
				generateCppFile(gen, f, serviceList)
			}
			if *lang == "rust" {
				generateRustFile(gen, f, serviceList)
			}
		}
		return nil
	})
}


func shouldGenerateService(serviceName string, serviceList map[string]bool) bool {
	if len(serviceList) == 0 {
		return true
	}
	return serviceList[serviceName]
}

// =============================================================================
// Go Code Generation
// =============================================================================

func generateGoFile(gen *protogen.Plugin, file *protogen.File, serviceList map[string]bool) {
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + "_ffi.pb.go"
	if idx := strings.LastIndex(filename, "/"); idx >= 0 {
		filename = filename[idx+1:]
	}
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// CGO import block for zero-copy FFI
	g.P("/*")
	g.P("#include <stdlib.h>")
	g.P("*/")
	g.P(`import "C"`)
	g.P()

	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"fmt"`)
	g.P(`	"unsafe"`)
	g.P()
	g.P(`	"github.com/ivere27/synurang/pkg/synurang"`)
	g.P(`	"google.golang.org/grpc"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()

	// Generate FfiServer interface
	g.P("type FfiServer interface {")
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		g.P("\t", service.GoName, "Server")
	}
	// Add streaming methods signatures
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				g.P("\t", method.GoName, "Internal(context.Context, *", g.QualifiedGoIdent(method.Input.GoIdent), ") (*", g.QualifiedGoIdent(method.Output.GoIdent), ", error)")
			}
		}
	}
	g.P("}")
	g.P()

	// Generate Invoke (returns []byte - for TCP/UDS)
	g.P("func Invoke(s FfiServer, ctx context.Context, method string, data []byte) ([]byte, error) {")
	g.P("\tswitch method {")

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			g.P(fmt.Sprintf(`	case "%s":`, methodName))
			g.P("\t\treq := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
			g.P("\t\tif err := proto.Unmarshal(data, req); err != nil {")
			g.P(`			return nil, fmt.Errorf("failed to unmarshal request: %w", err)`)
			g.P("\t\t}")

			callMethod := method.GoName
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				callMethod += "Internal"
			}

			g.P("\t\tresp, err := s.", callMethod, "(ctx, req)")
			g.P("\t\tif err != nil {")
			g.P("\t\t\treturn nil, err")
			g.P("\t\t}")
			g.P("\t\treturn proto.Marshal(resp)")
		}
	}

	g.P("\tdefault:")
	g.P(`		return nil, fmt.Errorf("unknown method: %s", method)`)
	g.P("\t}")
	g.P("}")
	g.P()

	// Generate InvokeFfi (returns C pointer - for zero-copy FFI)
	g.P("// InvokeFfi is the zero-copy variant for FFI mode.")
	g.P("// It allocates C memory and serializes directly into it.")
	g.P("// Caller is responsible for freeing the returned pointer via C.free().")
	g.P("func InvokeFfi(s FfiServer, ctx context.Context, method string, data []byte) (unsafe.Pointer, int64, error) {")
	g.P("\tswitch method {")

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			g.P(fmt.Sprintf(`	case "%s":`, methodName))
			g.P("\t\treq := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
			g.P("\t\tif err := proto.Unmarshal(data, req); err != nil {")
			g.P(`			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)`)
			g.P("\t\t}")

			callMethod := method.GoName
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				callMethod += "Internal"
			}

			g.P("\t\tresp, err := s.", callMethod, "(ctx, req)")
			g.P("\t\tif err != nil {")
			g.P("\t\t\treturn nil, 0, err")
			g.P("\t\t}")
			g.P("\t\t// Zero-copy: allocate C memory and serialize directly")
			g.P("\t\tsize := proto.Size(resp)")
			g.P("\t\tif size == 0 {")
			g.P("\t\t\treturn nil, 0, nil")
			g.P("\t\t}")
			g.P("\t\tcPtr := C.malloc(C.size_t(size))")
			g.P("\t\tbuf := unsafe.Slice((*byte)(cPtr), size)")
			g.P("\t\tif _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {")
			g.P("\t\t\tC.free(cPtr)")
			g.P("\t\t\treturn nil, 0, err")
			g.P("\t\t}")
			g.P("\t\treturn cPtr, int64(size), nil")
		}
	}

	g.P("\tdefault:")
	g.P(`		return nil, 0, fmt.Errorf("unknown method: %s", method)`)
	g.P("\t}")
	g.P("}")
	g.P()

	// Generate InvokeStream for streaming RPCs
	g.P("// InvokeStream dispatches streaming RPC calls to the appropriate server method.")
	g.P("func InvokeStream(s FfiServer, ctx context.Context, method string, stream grpc.ServerStream) error {")
	g.P("\tswitch method {")

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
				continue // Skip unary methods
			}

			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			g.P(fmt.Sprintf(`	case "%s":`, methodName))

			// Generate the typed stream wrapper (grpc prefix for serialization-based dispatch)
			streamType := fmt.Sprintf("grpc%s%sStream", service.GoName, method.GoName)

			if method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
				// Server streaming: Method(req, stream) error
				g.P("\t\t// Server streaming")
				g.P("\t\treq := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
				g.P("\t\tif err := stream.RecvMsg(req); err != nil {")
				g.P("\t\t\treturn err")
				g.P("\t\t}")
				g.P("\t\treturn s.", method.GoName, "(req, &", streamType, "{stream})")
			} else if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
				// Client streaming: Method(stream) error
				g.P("\t\t// Client streaming")
				g.P("\t\treturn s.", method.GoName, "(&", streamType, "{stream})")
			} else {
				// Bidi streaming: Method(stream) error
				g.P("\t\t// Bidi streaming")
				g.P("\t\treturn s.", method.GoName, "(&", streamType, "{stream})")
			}
		}
	}

	g.P("\tdefault:")
	g.P(`		return fmt.Errorf("unknown streaming method: %s", method)`)
	g.P("\t}")
	g.P("}")
	g.P()

	// Generate typed stream wrappers for each streaming method (for InvokeStream function)
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
				continue
			}

			streamType := fmt.Sprintf("grpc%s%sStream", service.GoName, method.GoName)

			g.P("// ", streamType, " wraps grpc.ServerStream for ", service.GoName, ".", method.GoName)
			g.P("type ", streamType, " struct {")
			g.P("\tgrpc.ServerStream")
			g.P("}")
			g.P()

			if method.Desc.IsStreamingServer() {
				// Add Send method
				g.P("func (s *", streamType, ") Send(m *", g.QualifiedGoIdent(method.Output.GoIdent), ") error {")
				g.P("\treturn s.ServerStream.SendMsg(m)")
				g.P("}")
				g.P()
			}

			if method.Desc.IsStreamingClient() {
				// Add Recv method
				g.P("func (s *", streamType, ") Recv() (*", g.QualifiedGoIdent(method.Input.GoIdent), ", error) {")
				g.P("\tm := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
				g.P("\tif err := s.ServerStream.RecvMsg(m); err != nil {")
				g.P("\t\treturn nil, err")
				g.P("\t}")
				g.P("\treturn m, nil")
				g.P("}")
				g.P()

				if !method.Desc.IsStreamingServer() {
					// Client streaming also needs SendAndClose
					g.P("func (s *", streamType, ") SendAndClose(m *", g.QualifiedGoIdent(method.Output.GoIdent), ") error {")
					g.P("\treturn s.ServerStream.SendMsg(m)")
					g.P("}")
					g.P()
				}
			}

			g.P("var _ ", service.GoName, "_", method.GoName, "Server = (*", streamType, ")(nil)")
			g.P()
		}
	}

	// ==========================================================================
	// Generate ffiInvoker - wraps FfiServer to implement synurang.Invoker
	// ==========================================================================
	g.P("// =============================================================================")
	g.P("// FFI Invoker - wraps FfiServer to implement synurang.Invoker interface")
	g.P("// =============================================================================")
	g.P()
	g.P("// ffiInvoker wraps FfiServer to implement the synurang.Invoker interface.")
	g.P("// This allows using the synurang runtime's FfiClientConn with generated code.")
	g.P("// Uses zero-copy: proto.Message pointers are passed directly without serialization.")
	g.P("type ffiInvoker struct {")
	g.P("\tserver FfiServer")
	g.P("}")
	g.P()

	// Generate Invoke for zero-copy unary
	g.P("// Invoke implements synurang.UnaryInvoker (zero-copy).")
	g.P("func (i *ffiInvoker) Invoke(ctx context.Context, method string, req, reply proto.Message) error {")
	g.P("\tswitch method {")

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			g.P(fmt.Sprintf(`	case "%s":`, methodName))

			callMethod := method.GoName
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				callMethod += "Internal"
			}

			g.P("\t\tresp, err := i.server.", callMethod, "(ctx, req.(*", g.QualifiedGoIdent(method.Input.GoIdent), "))")
			g.P("\t\tif err != nil {")
			g.P("\t\t\treturn err")
			g.P("\t\t}")
			g.P("\t\t// Zero-copy: direct struct copy")
			g.P("\t\tdst := reply.(*", g.QualifiedGoIdent(method.Output.GoIdent), ")")
			g.P("\t\t*dst = *resp")
			g.P("\t\treturn nil")
		}
	}

	g.P("\tdefault:")
	g.P(`		return fmt.Errorf("unknown method: %s", method)`)
	g.P("\t}")
	g.P("}")
	g.P()

	// Generate InvokeStream for zero-copy streaming
	g.P("// InvokeStream implements synurang.StreamInvoker (zero-copy).")
	g.P("func (i *ffiInvoker) InvokeStream(ctx context.Context, method string, stream synurang.ServerStream) error {")
	g.P("\tswitch method {")

	hasStreamingMethods := false
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
				continue // Skip unary methods
			}
			hasStreamingMethods = true

			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			g.P(fmt.Sprintf(`	case "%s":`, methodName))

			streamType := fmt.Sprintf("ffi%s%sStream", service.GoName, method.GoName)

			if method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
				// Server streaming
				g.P("\t\t// Server streaming (zero-copy)")
				g.P("\t\treqMsg, err := stream.RecvMsgDirect()")
				g.P("\t\tif err != nil {")
				g.P("\t\t\treturn err")
				g.P("\t\t}")
				g.P("\t\treq := reqMsg.(*", g.QualifiedGoIdent(method.Input.GoIdent), ")")
				g.P("\t\treturn i.server.", method.GoName, "(req, &", streamType, "{stream})")
			} else if method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
				// Client streaming
				g.P("\t\t// Client streaming (zero-copy)")
				g.P("\t\treturn i.server.", method.GoName, "(&", streamType, "{stream})")
			} else {
				// Bidi streaming
				g.P("\t\t// Bidi streaming (zero-copy)")
				g.P("\t\treturn i.server.", method.GoName, "(&", streamType, "{stream})")
			}
		}
	}

	g.P("\tdefault:")
	g.P(`		return fmt.Errorf("unknown streaming method: %s", method)`)
	g.P("\t}")
	g.P("}")
	g.P()

	// Generate stream wrappers for each streaming method
	if hasStreamingMethods {
		g.P("// =============================================================================")
		g.P("// Stream Wrappers (zero-copy)")
		g.P("// =============================================================================")
		g.P()
	}

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
				continue
			}

			streamType := fmt.Sprintf("ffi%s%sStream", service.GoName, method.GoName)

			g.P("// ", streamType, " wraps ServerStream for zero-copy ", service.GoName, ".", method.GoName)
			g.P("type ", streamType, " struct {")
			g.P("\tsynurang.ServerStream")
			g.P("}")
			g.P()

			// Add Context method
			g.P("func (s *", streamType, ") Context() context.Context {")
			g.P("\treturn s.ServerStream.Context()")
			g.P("}")
			g.P()

			if method.Desc.IsStreamingServer() {
				// Add Send method
				g.P("func (s *", streamType, ") Send(m *", g.QualifiedGoIdent(method.Output.GoIdent), ") error {")
				g.P("\treturn s.ServerStream.SendMsg(m)")
				g.P("}")
				g.P()
			}

			if method.Desc.IsStreamingClient() {
				// Add Recv method
				g.P("func (s *", streamType, ") Recv() (*", g.QualifiedGoIdent(method.Input.GoIdent), ", error) {")
				g.P("\tmsg, err := s.ServerStream.RecvMsgDirect()")
				g.P("\tif err != nil {")
				g.P("\t\treturn nil, err")
				g.P("\t}")
				g.P("\treturn msg.(*", g.QualifiedGoIdent(method.Input.GoIdent), "), nil")
				g.P("}")
				g.P()

				if !method.Desc.IsStreamingServer() {
					// Client streaming also needs SendAndClose
					g.P("func (s *", streamType, ") SendAndClose(m *", g.QualifiedGoIdent(method.Output.GoIdent), ") error {")
					g.P("\treturn s.ServerStream.SendMsg(m)")
					g.P("}")
					g.P()
				}
			}

			g.P("var _ ", service.GoName, "_", method.GoName, "Server = (*", streamType, ")(nil)")
			g.P()
		}
	}

	g.P("var _ synurang.Invoker = (*ffiInvoker)(nil)")
	g.P()

	// Generate NewFfiClientConn convenience function
	g.P("// =============================================================================")
	g.P("// FFI Client - convenience wrapper for synurang.FfiClientConn")
	g.P("// =============================================================================")
	g.P()
	g.P("// NewFfiClientConn creates a new FFI client connection that implements")
	g.P("// grpc.ClientConnInterface. This allows using standard generated gRPC clients")
	g.P("// with embedded FFI calls instead of network transport.")
	g.P("// Supports unary and all streaming patterns (server, client, bidi).")
	g.P("// Uses zero-copy mode for Go-to-Go FFI (no serialization overhead).")
	g.P("func NewFfiClientConn(server FfiServer) grpc.ClientConnInterface {")
	g.P("\treturn synurang.NewFfiClientConn(&ffiInvoker{server: server})")
	g.P("}")
	g.P()
}

// =============================================================================
// Dart Code Generation
// =============================================================================

func generateDartFile(gen *protogen.Plugin, file *protogen.File, serviceList map[string]bool, dartPackage string) {
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + "_ffi.pb.dart"
	if idx := strings.LastIndex(filename, "/"); idx >= 0 {
		filename = filename[idx+1:]
	}
	g := gen.NewGeneratedFile(filename, "")
	g.P("// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.")
	g.P()
	g.P("import 'dart:async';")
	g.P("import 'dart:typed_data';")
	g.P("import 'package:synurang/synurang.dart' as synurang;")

	// Import the corresponding pb.dart file
	baseProto := filepath.Base(file.Desc.Path())
	pbDart := strings.TrimSuffix(baseProto, ".proto") + ".pb.dart"
	g.P("import '", pbDart, "';")

	// Scan for external imports
	imports := map[string]bool{}
	addImport := func(path string) {
		if path == file.Desc.Path() {
			return
		}
		target := strings.TrimSuffix(path, ".proto") + ".pb.dart"
		var imp string
		if strings.HasPrefix(target, "google/protobuf/") {
			imp = "package:protobuf/well_known_types/" + target
		} else if dartPackage != "" {
			// Use package import if dart_package is specified
			imp = "package:" + dartPackage + "/" + target
		} else {
			// Use relative import
			rel, err := filepath.Rel(filepath.Dir(filename), target)
			if err != nil {
				imp = target
			} else {
				imp = filepath.ToSlash(rel)
			}
		}
		imports[imp] = true
	}

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			addImport(method.Input.Desc.ParentFile().Path())
			addImport(method.Output.Desc.ParentFile().Path())
		}
	}

	for imp := range imports {
		g.P("import '", imp, "';")
	}

	g.P()

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		g.P("class ", service.GoName, "Ffi {")
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())

			isServerStreaming := method.Desc.IsStreamingServer()
			isClientStreaming := method.Desc.IsStreamingClient()

			inputType := method.Input.GoIdent.GoName
			outputType := method.Output.GoIdent.GoName
			methodNameStr := string(method.Desc.Name())

			if !isServerStreaming && !isClientStreaming {
				// Unary RPC: Future<T> Method(Request r)
				g.P("  static Future<", outputType, "> ", methodNameStr, "(", inputType, " request) async {")
				g.P("    final bytes = request.writeToBuffer();")
				g.P(fmt.Sprintf("    final resultBytes = await synurang.invokeBackendAsync('%s', bytes);", methodName))
				g.P("    return ", outputType, ".fromBuffer(resultBytes);")
				g.P("  }")
			} else if isServerStreaming && !isClientStreaming {
				// Server streaming: Stream<T> Method(Request r)
				g.P("  static Stream<", outputType, "> ", methodNameStr, "(", inputType, " request) {")
				g.P("    final bytes = request.writeToBuffer();")
				g.P(fmt.Sprintf("    return synurang.invokeBackendServerStream('%s', bytes)", methodName))
				g.P("        .map((data) => ", outputType, ".fromBuffer(data));")
				g.P("  }")
			} else if isClientStreaming && !isServerStreaming {
				// Client streaming: Future<T> Method(Stream<Request> r)
				g.P("  static Future<", outputType, "> ", methodNameStr, "(Stream<", inputType, "> requests) async {")
				g.P(fmt.Sprintf("    final resultBytes = await synurang.invokeBackendClientStream('%s',", methodName))
				g.P("        requests.map((r) => r.writeToBuffer()));")
				g.P("    return ", outputType, ".fromBuffer(resultBytes);")
				g.P("  }")
			} else {
				// Bidi streaming: Stream<T> Method(Stream<Request> r)
				g.P("  static Stream<", outputType, "> ", methodNameStr, "(Stream<", inputType, "> requests) {")
				g.P(fmt.Sprintf("    return synurang.invokeBackendBidiStream('%s',", methodName))
				g.P("        requests.map((r) => r.writeToBuffer()))")
				g.P("        .map((data) => ", outputType, ".fromBuffer(data));")
				g.P("  }")
			}
			g.P()
		}
		g.P("}")
		g.P()
	}
}

// =============================================================================
// C++ Code Generation
// =============================================================================

func generateCppFile(gen *protogen.Plugin, file *protogen.File, serviceList map[string]bool) {
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + "_ffi.h"
	if idx := strings.LastIndex(filename, "/"); idx >= 0 {
		filename = filename[idx+1:]
	}
	g := gen.NewGeneratedFile(filename, "")
	g.P("// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.")
	g.P()

	// Header guard
	guardName := strings.ToUpper(strings.ReplaceAll(strings.TrimSuffix(filename, ".h"), ".", "_")) + "_H_"
	g.P("#ifndef ", guardName)
	g.P("#define ", guardName)
	g.P()

	g.P("#include <string>")
	g.P("#include <functional>")
	g.P("#include <memory>")
	g.P()

	// Import the corresponding pb.h file
	baseProto := filepath.Base(file.Desc.Path())
	pbHeader := strings.TrimSuffix(baseProto, ".proto") + ".pb.h"
	g.P("#include \"", pbHeader, "\"")
	g.P()

	// Determine namespace from package
	ns := strings.ReplaceAll(string(file.Desc.Package()), ".", "::")
	if ns != "" {
		g.P("namespace ", ns, " {")
		g.P()
	}

	// Generate FfiServer interface (abstract class)
	g.P("// =============================================================================")
	g.P("// FFI Server Interface")
	g.P("// =============================================================================")
	g.P()
	g.P("class FfiServer {")
	g.P("public:")
	g.P("  virtual ~FfiServer() = default;")
	g.P()

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		g.P("  // ", service.GoName, " methods")
		for _, method := range service.Methods {
			inputType := method.Input.GoIdent.GoName
			outputType := method.Output.GoIdent.GoName
			g.P("  virtual ", outputType, " ", method.GoName, "(const ", inputType, "& request) = 0;")
		}
		g.P()
	}
	g.P("};")
	g.P()

	// Generate Invoke function
	g.P("// =============================================================================")
	g.P("// FFI Dispatcher")
	g.P("// =============================================================================")
	g.P()
	g.P("inline std::string Invoke(FfiServer* server, const std::string& method, const std::string& data) {")

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			inputType := method.Input.GoIdent.GoName
			outputType := method.Output.GoIdent.GoName

			g.P("  if (method == \"", methodName, "\") {")
			g.P("    ", inputType, " req;")
			g.P("    if (!req.ParseFromString(data)) {")
			g.P("      return \"\";  // Parse error")
			g.P("    }")
			g.P("    ", outputType, " resp = server->", method.GoName, "(req);")
			g.P("    return resp.SerializeAsString();")
			g.P("  }")
		}
	}

	g.P("  return \"\";  // Unknown method")
	g.P("}")
	g.P()

	// Generate FfiChannel class
	g.P("// =============================================================================")
	g.P("// FFI Client Connection - routes calls through FFI instead of network")
	g.P("// =============================================================================")
	g.P()
	g.P("class FfiChannel {")
	g.P("public:")
	g.P("  explicit FfiChannel(FfiServer* server) : server_(server) {}")
	g.P()
	g.P("  template<typename Request, typename Response>")
	g.P("  bool Invoke(const std::string& method, const Request& request, Response* response) {")
	g.P("    std::string data = request.SerializeAsString();")
	if ns != "" {
		g.P("    std::string result = ::" + ns + "::Invoke(server_, method, data);")
	} else {
		g.P("    std::string result = Invoke(server_, method, data);")
	}
	g.P("    if (result.empty()) {")
	g.P("      return false;")
	g.P("    }")
	g.P("    return response->ParseFromString(result);")
	g.P("  }")
	g.P()
	g.P("private:")
	g.P("  FfiServer* server_;")
	g.P("};")
	g.P()

	// Generate typed client classes for each service
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		g.P("// =============================================================================")
		g.P("// ", service.GoName, " FFI Client")
		g.P("// =============================================================================")
		g.P()
		g.P("class ", service.GoName, "FfiClient {")
		g.P("public:")
		g.P("  explicit ", service.GoName, "FfiClient(FfiChannel* conn) : conn_(conn) {}")
		g.P("  explicit ", service.GoName, "FfiClient(FfiServer* server) : owned_conn_(std::make_unique<FfiChannel>(server)), conn_(owned_conn_.get()) {}")
		g.P()

		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			inputType := method.Input.GoIdent.GoName
			outputType := method.Output.GoIdent.GoName

			g.P("  bool ", method.GoName, "(const ", inputType, "& request, ", outputType, "* response) {")
			g.P("    return conn_->Invoke(\"", methodName, "\", request, response);")
			g.P("  }")
			g.P()
		}

		g.P("private:")
		g.P("  std::unique_ptr<FfiChannel> owned_conn_;")
		g.P("  FfiChannel* conn_;")
		g.P("};")
		g.P()
	}

	if ns != "" {
		g.P("} // namespace ", ns)
	}
	g.P()
	g.P("#endif // ", guardName)
}

// =============================================================================
// Rust Code Generation
// =============================================================================

func generateRustFile(gen *protogen.Plugin, file *protogen.File, serviceList map[string]bool) {
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + "_ffi.rs"
	if idx := strings.LastIndex(filename, "/"); idx >= 0 {
		filename = filename[idx+1:]
	}
	g := gen.NewGeneratedFile(filename, "")
	g.P("// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.")
	g.P()
	g.P("use prost::Message;")
	g.P("use std::sync::Arc;")
	g.P()

	// Determine module path from package
	modPath := strings.ReplaceAll(string(file.Desc.Package()), ".", "_")

	// Generate FfiServer trait
	g.P("// =============================================================================")
	g.P("// FFI Server Trait")
	g.P("// =============================================================================")
	g.P()
	g.P("pub trait FfiServer: Send + Sync {")
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			inputType := method.Input.GoIdent.GoName
			outputType := method.Output.GoIdent.GoName
			methodNameSnake := toSnakeCase(string(method.Desc.Name()))
			g.P("    fn ", methodNameSnake, "(&self, request: ", inputType, ") -> Result<", outputType, ", String>;")
		}
	}
	g.P("}")
	g.P()

	// Generate Invoke function
	g.P("// =============================================================================")
	g.P("// FFI Dispatcher")
	g.P("// =============================================================================")
	g.P()
	g.P("pub fn invoke<S: FfiServer>(server: &S, method: &str, data: &[u8]) -> Result<Vec<u8>, String> {")
	g.P("    match method {")

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			inputType := method.Input.GoIdent.GoName
			methodNameSnake := toSnakeCase(string(method.Desc.Name()))

			g.P("        \"", methodName, "\" => {")
			g.P("            let request = ", inputType, "::decode(data)")
			g.P("                .map_err(|e| format!(\"failed to decode request: {}\", e))?;")
			g.P("            let response = server.", methodNameSnake, "(request)?;")
			g.P("            let mut buf = Vec::new();")
			g.P("            response.encode(&mut buf)")
			g.P("                .map_err(|e| format!(\"failed to encode response: {}\", e))?;")
			g.P("            Ok(buf)")
			g.P("        }")
		}
	}

	g.P("        _ => Err(format!(\"unknown method: {}\", method)),")
	g.P("    }")
	g.P("}")
	g.P()

	// Generate FfiChannel struct
	g.P("// =============================================================================")
	g.P("// FFI Client Connection - routes calls through FFI instead of network")
	g.P("// =============================================================================")
	g.P()
	g.P("pub struct FfiChannel<S: FfiServer> {")
	g.P("    server: Arc<S>,")
	g.P("}")
	g.P()
	g.P("impl<S: FfiServer> FfiChannel<S> {")
	g.P("    pub fn new(server: Arc<S>) -> Self {")
	g.P("        FfiChannel { server }")
	g.P("    }")
	g.P()
	g.P("    pub fn invoke<Req: Message, Resp: Message + Default>(&self, method: &str, request: &Req) -> Result<Resp, String> {")
	g.P("        let mut data = Vec::new();")
	g.P("        request.encode(&mut data)")
	g.P("            .map_err(|e| format!(\"failed to encode request: {}\", e))?;")
	g.P("        let result = invoke(&*self.server, method, &data)?;")
	g.P("        Resp::decode(result.as_slice())")
	g.P("            .map_err(|e| format!(\"failed to decode response: {}\", e))")
	g.P("    }")
	g.P("}")
	g.P()

	// Generate typed client structs for each service
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}

		g.P("// =============================================================================")
		g.P("// ", service.GoName, " FFI Client")
		g.P("// =============================================================================")
		g.P()
		g.P("pub struct ", service.GoName, "FfiClient<S: FfiServer> {")
		g.P("    conn: FfiChannel<S>,")
		g.P("}")
		g.P()
		g.P("impl<S: FfiServer> ", service.GoName, "FfiClient<S> {")
		g.P("    pub fn new(server: Arc<S>) -> Self {")
		g.P("        ", service.GoName, "FfiClient {")
		g.P("            conn: FfiChannel::new(server),")
		g.P("        }")
		g.P("    }")
		g.P()

		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			inputType := method.Input.GoIdent.GoName
			outputType := method.Output.GoIdent.GoName
			methodNameSnake := toSnakeCase(string(method.Desc.Name()))

			g.P("    pub fn ", methodNameSnake, "(&self, request: &", inputType, ") -> Result<", outputType, ", String> {")
			g.P("        self.conn.invoke(\"", methodName, "\", request)")
			g.P("    }")
			g.P()
		}

		g.P("}")
		g.P()
	}

	// Module info comment
	g.P("// Module: ", modPath)
}

// toSnakeCase converts CamelCase to snake_case
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}
