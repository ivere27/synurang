package main

import (
	"flag"
	"fmt"
	"path/filepath"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	var flags flag.FlagSet
	lang := flags.String("lang", "", "language to generate (go, dart, cpp, or rust)")
	dartPackage := flags.String("dart_package", "", "Dart package name for imports (e.g. my_app). If set, generates package imports.")
	services := flags.String("services", "", "comma-separated list of services to generate for (empty for all)")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		serviceList := make(map[string]bool)
		if *services != "" {
			for _, s := range strings.Split(*services, ",") {
				serviceList[strings.TrimSpace(s)] = true
			}
		}

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if *lang == "go" || *lang == "" {
				generateGoFile(gen, f, serviceList)
			}
			if *lang == "dart" || *lang == "" {
				generateDartFile(gen, f, serviceList, *dartPackage)
			}
			if *lang == "cpp" {
				generateCppFile(gen, f, serviceList)
			}
			if *lang == "rust" {
				generateRustFile(gen, f, serviceList)
			}
		}
		return nil
	})
}


func shouldGenerateService(serviceName string, serviceList map[string]bool) bool {
	if len(serviceList) == 0 {
		return true
	}
	return serviceList[serviceName]
}

// =============================================================================
// Go Code Generation
// =============================================================================

func generateGoFile(gen *protogen.Plugin, file *protogen.File, serviceList map[string]bool) {
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + "_ffi.pb.go"
	if idx := strings.LastIndex(filename, "/"); idx >= 0 {
		filename = filename[idx+1:]
	}
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// CGO import block for zero-copy FFI
	g.P("/*")
	g.P("#include <stdlib.h>")
	g.P("*/")
	g.P(`import "C"`)
	g.P()

	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"fmt"`)
	g.P(`	"unsafe"`)
	g.P(`	"google.golang.org/protobuf/proto"`)
	g.P(")")
	g.P()

	// Generate FfiServer interface
	g.P("type FfiServer interface {")
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		g.P(service.GoName, "Server")
	}
	// Add streaming methods signatures
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				g.P(method.GoName, "Internal(context.Context, *", g.QualifiedGoIdent(method.Input.GoIdent), ") (*", g.QualifiedGoIdent(method.Output.GoIdent), ", error)")
			}
		}
	}
	g.P("}")
	g.P()

	// Generate Invoke (returns []byte - for TCP/UDS)
	g.P("func Invoke(s FfiServer, ctx context.Context, method string, data []byte) ([]byte, error) {")
	g.P("	switch method {")

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			g.P(fmt.Sprintf(`	case "%s":`, methodName))
			g.P("		req := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
			g.P("		if err := proto.Unmarshal(data, req); err != nil {")
			g.P(`			return nil, fmt.Errorf("failed to unmarshal request: %w", err)`)
			g.P("		}")

			callMethod := method.GoName
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				callMethod += "Internal"
			}

			g.P("		resp, err := s.", callMethod, "(ctx, req)")
			g.P("		if err != nil {")
			g.P("			return nil, err")
			g.P("		}")
			g.P("		return proto.Marshal(resp)")
		}
	}

	g.P("	default:")
	g.P(`		return nil, fmt.Errorf("unknown method: %s", method)`)
	g.P("	}")
	g.P("}")
	g.P()

	// Generate InvokeFfi (returns C pointer - for zero-copy FFI)
	g.P("// InvokeFfi is the zero-copy variant for FFI mode.")
	g.P("// It allocates C memory and serializes directly into it.")
	g.P("// Caller is responsible for freeing the returned pointer via C.free().")
	g.P("func InvokeFfi(s FfiServer, ctx context.Context, method string, data []byte) (unsafe.Pointer, int64, error) {")
	g.P("	switch method {")

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			g.P(fmt.Sprintf(`	case "%s":`, methodName))
			g.P("		req := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
			g.P("		if err := proto.Unmarshal(data, req); err != nil {")
			g.P(`			return nil, 0, fmt.Errorf("failed to unmarshal request: %w", err)`)
			g.P("		}")

			callMethod := method.GoName
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				callMethod += "Internal"
			}

			g.P("		resp, err := s.", callMethod, "(ctx, req)")
			g.P("		if err != nil {")
			g.P("			return nil, 0, err")
			g.P("		}")
			g.P("		// Zero-copy: allocate C memory and serialize directly")
			g.P("		size := proto.Size(resp)")
			g.P("		if size == 0 {")
			g.P("			return nil, 0, nil")
			g.P("		}")
			g.P("		cPtr := C.malloc(C.size_t(size))")
			g.P("		buf := unsafe.Slice((*byte)(cPtr), size)")
			g.P("		if _, err := (proto.MarshalOptions{}).MarshalAppend(buf[:0], resp); err != nil {")
			g.P("			C.free(cPtr)")
			g.P("			return nil, 0, err")
			g.P("		}")
			g.P("		return cPtr, int64(size), nil")
		}
	}

	g.P("	default:")
	g.P(`		return nil, 0, fmt.Errorf("unknown method: %s", method)`)
	g.P("	}")
	g.P("}")
}

// =============================================================================
// Dart Code Generation
// =============================================================================

func generateDartFile(gen *protogen.Plugin, file *protogen.File, serviceList map[string]bool, dartPackage string) {
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + "_ffi.pb.dart"
	g := gen.NewGeneratedFile(filename, "")
	g.P("// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.")
	g.P()
	g.P("import 'dart:async';")
	g.P("import 'dart:typed_data';")
	g.P("import 'package:synurang/synurang.dart' as synurang;")

	// Import the corresponding pb.dart file
	baseProto := filepath.Base(file.Desc.Path())
	pbDart := strings.TrimSuffix(baseProto, ".proto") + ".pb.dart"
	g.P("import '", pbDart, "';")

	// Scan for external imports
	imports := map[string]bool{}
	addImport := func(path string) {
		if path == file.Desc.Path() {
			return
		}
		target := strings.TrimSuffix(path, ".proto") + ".pb.dart"
		var imp string
		if strings.HasPrefix(target, "google/protobuf/") {
			imp = "package:protobuf/well_known_types/" + target
		} else if dartPackage != "" {
			// Use package import if dart_package is specified
			imp = "package:" + dartPackage + "/" + target
		} else {
			// Use relative import
			rel, err := filepath.Rel(filepath.Dir(filename), target)
			if err != nil {
				imp = target
			} else {
				imp = filepath.ToSlash(rel)
			}
		}
		imports[imp] = true
	}

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		for _, method := range service.Methods {
			addImport(method.Input.Desc.ParentFile().Path())
			addImport(method.Output.Desc.ParentFile().Path())
		}
	}

	for imp := range imports {
		g.P("import '", imp, "';")
	}

	g.P()

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		g.P("class ", service.GoName, "Ffi {")
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())

			isServerStreaming := method.Desc.IsStreamingServer()
			isClientStreaming := method.Desc.IsStreamingClient()

			inputType := method.Input.GoIdent.GoName
			outputType := method.Output.GoIdent.GoName
			methodNameStr := string(method.Desc.Name())

			if !isServerStreaming && !isClientStreaming {
				// Unary RPC: Future<T> Method(Request r)
				g.P("  static Future<", outputType, "> ", methodNameStr, "(", inputType, " request) async {")
				g.P("    final bytes = request.writeToBuffer();")
				g.P(fmt.Sprintf("    final resultBytes = await synurang.invokeBackendAsync('%s', bytes);", methodName))
				g.P("    return ", outputType, ".fromBuffer(resultBytes);")
				g.P("  }")
			} else if isServerStreaming && !isClientStreaming {
				// Server streaming: Stream<T> Method(Request r)
				g.P("  static Stream<", outputType, "> ", methodNameStr, "(", inputType, " request) {")
				g.P("    final bytes = request.writeToBuffer();")
				g.P(fmt.Sprintf("    return synurang.invokeBackendServerStream('%s', bytes)", methodName))
				g.P("        .map((data) => ", outputType, ".fromBuffer(data));")
				g.P("  }")
			} else if isClientStreaming && !isServerStreaming {
				// Client streaming: Future<T> Method(Stream<Request> r)
				g.P("  static Future<", outputType, "> ", methodNameStr, "(Stream<", inputType, "> requests) async {")
				g.P(fmt.Sprintf("    final resultBytes = await synurang.invokeBackendClientStream('%s',", methodName))
				g.P("        requests.map((r) => r.writeToBuffer()));")
				g.P("    return ", outputType, ".fromBuffer(resultBytes);")
				g.P("  }")
			} else {
				// Bidi streaming: Stream<T> Method(Stream<Request> r)
				g.P("  static Stream<", outputType, "> ", methodNameStr, "(Stream<", inputType, "> requests) {")
				g.P(fmt.Sprintf("    return synurang.invokeBackendBidiStream('%s',", methodName))
				g.P("        requests.map((r) => r.writeToBuffer()))")
				g.P("        .map((data) => ", outputType, ".fromBuffer(data));")
				g.P("  }")
			}
			g.P()
		}
		g.P("}")
		g.P()
	}
}

// =============================================================================
// C++ Code Generation
// =============================================================================

func generateCppFile(gen *protogen.Plugin, file *protogen.File, serviceList map[string]bool) {
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + "_ffi.cc"
	if idx := strings.LastIndex(filename, "/"); idx >= 0 {
		filename = filename[idx+1:]
	}
	g := gen.NewGeneratedFile(filename, "")
	g.P("// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.")
	g.P()
	g.P("#include <string>")
	g.P("#include <vector>")
	g.P("#include <grpcpp/grpcpp.h>")
	g.P("#include \"synurang.hpp\"") // Assuming a core runtime header
	
	// Import the corresponding pb.h file
	baseProto := filepath.Base(file.Desc.Path())
	pbHeader := strings.TrimSuffix(baseProto, ".proto") + ".pb.h"
	g.P("#include \"", pbHeader, "\"")

	g.P()
	g.P("using namespace grpc;")
	g.P("using namespace std;")
	g.P()

	// Determine namespace from package
	ns := strings.ReplaceAll(string(file.Desc.Package()), ".", "::")
	if ns != "" {
		g.P("namespace ", ns, " {")
	}

	// Generate Dispatcher Class
	g.P("class FfiDispatcher {")
	g.P("public:")
	g.P("  static std::string Invoke(grpc::Service* service, const std::string& method, const std::string& data) {")
	g.P("    // Generic dispatch implementation")
	
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		g.P("    // Service: ", service.GoName)
		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			g.P("    if (method == \"", methodName, "\") {")
			
			inputType := method.Input.GoIdent.GoName
			outputType := method.Output.GoIdent.GoName
			
			// Note: C++ protobuf classes use nested namespaces matching the proto package
			// Here we assume the generated C++ code follows standard mapping
			cppInputType := inputType
			cppOutputType := outputType

			g.P("      ", cppInputType, " req;")
			g.P("      if (!req.ParseFromString(data)) return \"\";") // TODO: Error handling
			g.P("      ", cppOutputType, " resp;")
			g.P("      ServerContext ctx;")
			g.P("      // Cast generic service to specific service")
			g.P("      auto* s = static_cast<", service.GoName, "::Service*>(service);")
			g.P("      Status status = s->", method.GoName, "(&ctx, &req, &resp);")
			g.P("      if (!status.ok()) return \"\";") // TODO: Error handling
			g.P("      return resp.SerializeAsString();")
			g.P("    }")
		}
	}
	
	g.P("    return \"\";")
	g.P("  }")
	g.P("};")
	
	if ns != "" {
		g.P("} // namespace ", ns)
	}
}

// =============================================================================
// Rust Code Generation
// =============================================================================

func generateRustFile(gen *protogen.Plugin, file *protogen.File, serviceList map[string]bool) {
	filename := strings.TrimSuffix(file.Desc.Path(), ".proto") + "_ffi.rs"
	if idx := strings.LastIndex(filename, "/"); idx >= 0 {
		filename = filename[idx+1:]
	}
	g := gen.NewGeneratedFile(filename, "")
	g.P("// Code generated by protoc-gen-synurang-ffi. DO NOT EDIT.")
	g.P()
	g.P("use std::collections::HashMap;")
	g.P("use std::ffi::{c_char, c_void, CStr};")
	g.P("use std::slice;")
	g.P("use synurang::{FfiData, GeneratedService};")
	g.P()

	// Determine module path from package
	modPath := strings.ReplaceAll(string(file.Desc.Package()), ".", "_")

	g.P("/// Generated service trait for FFI dispatch")
	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		g.P("pub trait ", service.GoName, "Service {")
		for _, method := range service.Methods {
			inputType := method.Input.GoIdent.GoName
			outputType := method.Output.GoIdent.GoName
			methodNameSnake := toSnakeCase(string(method.Desc.Name()))
			g.P("    fn ", methodNameSnake, "(&self, request: &[u8]) -> Result<Vec<u8>, String>;")
			_ = inputType
			_ = outputType
		}
		g.P("}")
		g.P()
	}

	// Generate dispatcher
	g.P("/// FFI Dispatcher - routes method calls to service implementations")
	g.P("pub struct FfiDispatcher<S> {")
	g.P("    service: S,")
	g.P("}")
	g.P()

	for _, service := range file.Services {
		if !shouldGenerateService(service.GoName, serviceList) {
			continue
		}
		g.P("impl<S: ", service.GoName, "Service> FfiDispatcher<S> {")
		g.P("    pub fn new(service: S) -> Self {")
		g.P("        FfiDispatcher { service }")
		g.P("    }")
		g.P("}")
		g.P()
		
		g.P("impl<S: ", service.GoName, "Service + Send + Sync> GeneratedService for FfiDispatcher<S> {")
		g.P("    fn invoke(&self, method: &str, data: &[u8]) -> Result<Vec<u8>, String> {")
		g.P("        match method {")

		for _, method := range service.Methods {
			methodName := fmt.Sprintf("/%s.%s/%s", file.Desc.Package(), service.Desc.Name(), method.Desc.Name())
			methodNameSnake := toSnakeCase(string(method.Desc.Name()))
			g.P(fmt.Sprintf(`            "%s" => self.service.%s(data),`, methodName, methodNameSnake))
		}

		g.P(`            _ => Err(format!("unknown method: {}", method)),`)
		g.P("        }")
		g.P("    }")
		g.P("}")
		g.P()
	}

	// Module info comment
	g.P("// Module: ", modPath)
}

// toSnakeCase converts CamelCase to snake_case
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}
